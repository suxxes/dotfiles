#!/bin/bash
# chezmoi:template:left-delimiter="# {{" right-delimiter="}}"
# Generates ~/.config/secrets/env.fish from 1Password Secrets vault
# Fetches: all items NOT matching "LXC: ..." + items matching "LXC: <hostname>"
# Hash: # {{ include "dot_config/fish/conf.d/50-secrets.fish.tmpl" | sha256sum }}

set -e

# {{ if eq .osType "darwin" }}
# macOS: secrets loaded directly in fish, skip generation
exit 0
# {{ end }}

SECRETS_DIR="$HOME/.config/secrets"
SECRETS_FILE="$SECRETS_DIR/env.fish"
HOSTNAME=$(hostname)

mkdir -p "$SECRETS_DIR"

echo "# Auto-generated by chezmoi - do not edit" > "$SECRETS_FILE"
echo "# Generated: $(date -Iseconds)" >> "$SECRETS_FILE"
echo "# Hostname: $HOSTNAME" >> "$SECRETS_FILE"
echo "" >> "$SECRETS_FILE"

# Check if op is available and authenticated
if ! command -v op &> /dev/null; then
    echo "# ERROR: 1Password CLI not installed" >> "$SECRETS_FILE"
    exit 0
fi

if ! op account list &> /dev/null; then
    echo "# ERROR: Not authenticated to 1Password" >> "$SECRETS_FILE"
    exit 0
fi

# Get all items from Secrets vault
ITEMS=$(op item list --vault Secrets --format json 2>/dev/null || echo "[]")

if [ "$ITEMS" = "[]" ]; then
    echo "# WARNING: No items found in Secrets vault" >> "$SECRETS_FILE"
    exit 0
fi

# Process each item
echo "$ITEMS" | jq -r '.[] | .title' | while read -r TITLE; do
    # Skip Service Account Token
    if [[ "$TITLE" == "Service Account Token" ]]; then
        continue
    fi

    # Handle LXC-specific items
    if [[ "$TITLE" == LXC:* ]]; then
        # Extract hostname from "LXC: hostname" or "LXC:hostname"
        ITEM_HOST=$(echo "$TITLE" | sed 's/^LXC: *//')
        if [[ "$ITEM_HOST" != "$HOSTNAME" ]]; then
            continue
        fi
        echo "# From: $TITLE (container-specific)" >> "$SECRETS_FILE"
    else
        # Include all non-LXC items (shared secrets)
        echo "# From: $TITLE" >> "$SECRETS_FILE"
    fi

    # Get all fields from this item (excluding notes)
    FIELDS=$(op item get "$TITLE" --vault Secrets --format json 2>/dev/null | \
        jq -r '.fields[]? | select(.value != null and .value != "") | select(.id != "notesPlain") | "\(.label)=\(.value)"' 2>/dev/null || echo "")

    while IFS='=' read -r KEY VALUE; do
        if [ -n "$KEY" ] && [ -n "$VALUE" ]; then
            # Sanitize key: uppercase, replace spaces/dashes with underscore
            CLEAN_KEY=$(echo "$KEY" | tr '[:lower:]' '[:upper:]' | tr ' -' '_' | tr -cd '[:alnum:]_')
            # Escape double quotes in value
            ESCAPED_VALUE=$(echo "$VALUE" | sed 's/"/\\"/g')
            echo "set -gx $CLEAN_KEY \"$ESCAPED_VALUE\"" >> "$SECRETS_FILE"
        fi
    done <<< "$FIELDS"

    echo "" >> "$SECRETS_FILE"
done

chmod 600 "$SECRETS_FILE"
echo "Generated secrets file: $SECRETS_FILE"

# Setup SSH key for git operations
SSH_DIR="$HOME/.ssh"
SSH_KEY="$SSH_DIR/id_ed25519"

mkdir -p "$SSH_DIR"
chmod 700 "$SSH_DIR"

# Fetch private key from 1Password
PRIVATE_KEY=$(op read "op://Secrets/LXC SSH Key/private key" 2>/dev/null || echo "")

if [ -n "$PRIVATE_KEY" ]; then
    echo "$PRIVATE_KEY" > "$SSH_KEY"
    chmod 600 "$SSH_KEY"

    PUBLIC_KEY=$(op read "op://Secrets/LXC SSH Key/public key" 2>/dev/null || echo "")
    if [ -n "$PUBLIC_KEY" ]; then
        echo "$PUBLIC_KEY" > "$SSH_KEY.pub"
        chmod 644 "$SSH_KEY.pub"

        echo "$PUBLIC_KEY" > "$SSH_DIR/authorized_keys"
        chmod 600 "$SSH_DIR/authorized_keys"
        echo "Installed authorized_keys"
    fi
    echo "Installed SSH key: $SSH_KEY"
else
    echo "WARNING: Could not fetch SSH key from 1Password"
fi
